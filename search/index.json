[{"content":"自建内网穿透 在校园网环境下向互联网暴露自己的http服务器.\n背景 需求 希望我的手机能随时通过数据网络访问到我的pc.\n我写的自用的安卓软件TORRID有一些功能在如果我的pc提供的http服务器能够在公网被随时访问那会方便很多:\n打卡、随笔等页面产生的用户数据的备份、同步\n浏览大体积媒体文件时, 通过http访问pc上的资源而非将漫画存于手机本地. (虽然正常来说都是这么做, 但之前由于没有办法随时随地连接到pc图方便看漫画就存在本地了.)\n环境 一台带有固定公网ip的低配低宽带的云服务器 (甚至还是共享型)\n由于云服务器实在是低配置而且宽带低的可怜, 所以它仅作为内网穿透的工具而使用, 仅看中了他的固定的公网ip这一优点. pc处于全锥型NAT校园网环境 (最宽松的NAT类型).\n手机使用对称型NAT数据网络 (最严格限制的类型).\n校园网环境下的设备只有内网ip, 只有主动向外部网络发起请求的时候才会获得临时的公网ip+随机端口\n实现效果 任何连入互联网的设备都能访问到我位于校园网内的pc提供的http服务.\n实现 实现原理 云服务器运行程序:\n监听8000端口, 接收pc发来的经过NAT后的ip和端口号. 监听8080端口, 响应手机的http请求告知其记录的ip:port信息. pc端运行程序:\n在某一端口运行http服务器, 运行数据备份同步, 响应漫画数据等业务数据逻辑. (此时服务器仅运行于pc本地及路由器网络下如寝室网内) 通过设置端口复用, 同样使用该端口向云服务器的8000端口发送长TCP连接并以小于1/2超时时长的间隔持续不断的发送空数据的心跳包维持这个连接使从校园网获取到的临时port能够持续维系下去. 手机端的应用则可以通过访问云服务器的8080端口获知pc的网络地址, 并实现向pc的单向网络通信. 云服务器端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) // 存储PC的公网NAT地址（IP:端口） var pcAddr string func main() { // 1. 启动TCP服务，接收PC的长连接并记录其NAT地址 go func() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8000\u0026#34;) if err != nil { log.Fatalf(\u0026#34;TCP监听失败: %v\u0026#34;, err) } defer listener.Close() for { // 只处理第一个PC连接（自用场景） conn, err := listener.Accept() if err != nil { log.Printf(\u0026#34;接收连接失败: %v\u0026#34;, err) continue } // 记录PC的公网NAT地址（conn.RemoteAddr()返回的是NAT映射后的地址） pcAddr = conn.RemoteAddr().String() log.Printf(\u0026#34;PC已连接，NAT地址: %s\u0026#34;, pcAddr) // 保持连接（读取数据防止连接被关闭，PC会发心跳） go func(c net.Conn) { defer c.Close() c.SetReadDeadline(time.Now().Add(25 * time.Second)) buf := make([]byte, 1024) for { _, err := c.Read(buf) if err != nil { if !strings.Contains(err.Error(), \u0026#34;closed\u0026#34;) { log.Printf(\u0026#34;PC连接断开: %v\u0026#34;, err) } pcAddr = \u0026#34;\u0026#34; // 清空地址 return } // 读超时时间设置. c.SetReadDeadline(time.Now().Add(45 * time.Second)) } }(conn) } }() // 2. 启动HTTP服务，供手机查询PC的NAT地址 http.HandleFunc(\u0026#34;/get-pc-addr\u0026#34;, func(w http.ResponseWriter, r *http.Request) { if pcAddr == \u0026#34;\u0026#34; { w.WriteHeader(http.StatusNotFound) w.Write([]byte(\u0026#34;PC未连接\u0026#34;)) return } w.Write([]byte(pcAddr)) // 返回格式: \u0026#34;公网IP:端口\u0026#34; }) log.Println(\u0026#34;云服务器启动，TCP端口:8000，HTTP查询端口:8080\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } 云服务器在这里的作用仅相当于所有人都知道位置的留言板. pc端在此处留下自己的网络地址, 手机端根据留言板上的留言向pc端发送网络请求, 我去感觉我这个比喻打得相当恰当啊. pc端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) const ( serverIP = \u0026#34;替换为实际云服务器IP\u0026#34; // 替换为实际云服务器IP serverPort = 8000 // 云服务器TCP端口（与服务端对应） localPort = 7274 // 本地端口（同时用于HTTP服务和长连接） interval = 20 ) func main() { // 1. 启动本地HTTP服务（端口，供手机访问） go func() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;手机访问PC成功！\u0026#34;)) }) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;:%d\u0026#34;, localPort)) if err != nil { log.Fatalf(\u0026#34;本地HTTP服务启动失败: %v\u0026#34;, err) } log.Printf(\u0026#34;本地HTTP服务已启动，端口: %d\u0026#34;, localPort) log.Fatal(http.Serve(listener, mux)) }() // 2. 与云服务器建立长连接并维持NAT映射 for { dialer := net.Dialer{ LocalAddr: \u0026amp;net.TCPAddr{Port: localPort}, Timeout: 10 * time.Second, } conn, err := dialer.Dial(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, serverIP, serverPort)) if err != nil { log.Printf(\u0026#34;连接云服务器失败，5秒后重试: %v\u0026#34;, err) time.Sleep(5 * time.Second) continue } log.Println(\u0026#34;与云服务器建立长连接成功，开始发送心跳\u0026#34;) heartbeatTicker := time.NewTicker(interval * time.Second) // 使用标志位控制内层循环，避免直接return导致流程不清晰 running := true // 单独的资源释放函数，确保在各种退出路径下都能正确释放资源 cleanup := func() { heartbeatTicker.Stop() conn.Close() log.Println(\u0026#34;长连接断开，准备重连\u0026#34;) } // 内层循环处理心跳逻辑，使用标志位控制退出 for running { select { case \u0026lt;-heartbeatTicker.C: fmt.Println(\u0026#34;续命成功.\u0026#34;) _, err := conn.Write([]byte(\u0026#34;heartbeat\u0026#34;)) if err != nil { log.Printf(\u0026#34;心跳发送失败: %v\u0026#34;, err) running = false // 设置退出标志 } } } // 执行资源清理 cleanup() // 等待一小段时间再重连，避免频繁重试 time.Sleep(2 * time.Second) } } \u0026ldquo;启动本地http服务\u0026quot;处做修改承担起实际业务, 响应漫画资源和数据备份同步等. 移动端代码 -\u0026gt; 后续有时间了改改我的安卓应用TORRID, 利用好这个工具.\n完毕 摸索的过程\n很早就有这个想法了, 看到29元/年的云服务器这还说啥了, 我下单就是了.\n前后大概一周的时间:\n稍微了解了Go这门语言, 作为服务端语言, 可编译为单一的二进制文件很适合部署到云服务器上. 了解了网络相关的入门知识, 了解了内网穿透, p2p的实现原理. 最后接近一整天的时间, 实际上手实现这一过程. 助手\n豆包用起来的话, 感觉他啥都知道, 但有时候就是一句话都不多讲, 问什么讲什么, 提出什么需求就只解决哪个,\n比如如下这一过程:\n他告诉我为了使经NAT后的临时端口保持不被销毁, 需要pc端持续不断地向云服务器发送网络请求. 让他生成响应代码, 他返回了但端口还是会不断变化, 问来问去才知道网络请求是会随机采取本地端口向外连接, 由于NAT映射的四元组规则, 这会直接导致新分配另外一个临时端口. 让他每次都使用同一本地端口请求, 它返回的代码运行一会儿就崩了, 说是端口占用, 因为他只实现了我提出的每次使用同一本地端口的需求, 而甚至不多思考一步关闭原先端口 \u0026hellip;\u0026hellip; 后来了解到了TCP长连接, 心跳包等概念, 终于让它生成可用的代码了. 如上只是pc端代码的向云服务器留言这一功能的摸索过程\u0026hellip;\u0026hellip; 总而言之, 豆包好用, 这一实现借助它才得以完成, 但是摸索的这一过程常常陷入低效的碰壁, 哪天考虑考虑别的响应更快, 思考的更远的AI呢.\n可恶\n令人佩服的效率和耐心\u0026hellip;\n骗你的, 不止六七小时.\n","date":"2025-11-05T16:48:41+08:00","permalink":"https://zx1360.github.io/p/%E5%88%9D%E8%AF%95%E8%87%AA%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","title":"初试自建内网穿透"},{"content":"NAT 私网内设备访问外网时, 路由器对其源ip:port转为唯一公网ip:随机端口\n类型 核心特点 全锥型（Full Cone） 1. 内网设备主动访问外网后，会开放一个固定公网端口；2. 任何外网设备，只要知道这个公网端口，都能主动连接内网设备。 地址受限锥型（Address-Restricted Cone） 1. 仅允许 “内网设备主动访问过的外网 IP” 发起反向连接；2. 不限制外网设备的端口，只验证 IP 是否匹配。 端口受限锥型（Port-Restricted Cone） 1. 比地址受限更严格，仅允许 “内网设备主动访问过的外网 IP + 对应端口” 发起反向连接；2. IP 或端口有一个不匹配，连接就会被拒绝。 对称型（Symmetric） 1. 内网设备访问不同外网目标时，会分配不同的公网端口；2. 外网设备无法主动发起任何反向连接，仅支持内网主动发起的单向通信。 对称型对不同的目标地址访问都会分配不同的端口. 除了全锥型都会过滤掉 非活跃会话==且==非主动发起 的请求来源. NAT的存在使得内网设备几乎只能主动访问外部网络, 对外部来说, 内网部分不仅不透明还有可能被NAT过度保护. 内网穿透 内网设备向公共服务器建立连接, 其他设备通过请求公共服务器来间接与内网通信\np2p 利用机制\n即使是对称型NAT, 请求一个地址之后的临时port, 被另外地址的请求访问, 会视为原先的目标地址的回应, 会\u0026quot;放行\u0026quot;, 双方向中间服务器请求, 留下各自的ip:port, 中间服务器分别响应其另外一方的信息. 双方收到消息之后立刻高频率发送对应的请求, 争取在其之前的port失效之前\u0026quot;续\u0026quot;上有效性. 至此双方都有了对方承认的数据通道, 之后以1/2port失效期的间隔发送空数据的心跳包, 保持通道有效性. ","date":"2025-11-02T16:37:54+08:00","permalink":"https://zx1360.github.io/p/p2p%E5%AD%A6%E4%B9%A0/","title":"P2p学习"},{"content":"[toc]\n实现了(几乎)自动化的博客网站.\n本地写博客内容推送到github 利用github Action使用hugo自动构建静态网页. 静态网页构建方案 Hugo\n官网: The world\u0026rsquo;s fastest framework for building websites\nhugo new site [hugo项目名] 下载主题到themes目录 图省事就直接把themes中exampleSite之类的东西中content, hugo.yaml之类的东西直接复制到项目根目录对应位置再稍微改改. hugo server --buildDrafts 本地预览. 监听推送, 构建内容. 使用github Action.\n推荐由Action自动创建另外的分支而非手动, 避免不必要的版本冲突.\n在项目根路径下创建.github\\workflows\\deploy.yml, 包含在git内容里.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 name: Deploy Hugo Site to GitHub Pages # 触发条件：推送到 main 分支时执行 on: push: branches: [ main ] # ⭐ 赋予工作流写入权限. permissions: contents: write jobs: deploy: runs-on: ubuntu-latest steps: # 步骤 1：拉取仓库代码 - name: Checkout code uses: actions/checkout@v4 with: # submodules: true # 若主题通过 Git Submodule 管理，必须设为 true fetch-depth: 0 # 拉取完整历史，避免 Hugo 构建时出错 # 步骤 2：安装 Hugo（根据你的 Hugo 版本选择，这里以 0.124.1 为例） - name: Install Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.152.2\u0026#39; # 替换为你的 Hugo 版本（可在本地用 hugo version 查看） extended: true # 若使用了 SCSS/Sass 等扩展功能，需设为 true # 步骤 3：构建静态文件（生成 public 目录） - name: Build Hugo site run: hugo --buildDrafts # 若需要构建草稿，可改为 hugo --buildDrafts # 步骤 4：部署到 GitHub Pages - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: # 部署权限：使用 GitHub 提供的默认密钥（无需手动生成） github_token: ${{ secrets.GITHUB_TOKEN }} # 部署源：Hugo 构建后的 public 目录 publish_dir: ./public # 部署目标分支：GitHub Pages 读取的分支（默认 gh-pages，可修改） publish_branch: gh-pages # ⭐ 每次部署都会创建一个全新的、无历史记录的 gh-pages 分支 force_orphan: true 之后每次向远程仓库的main分支提交时会触发工作流, 大概十多秒到半分钟会将构建好的内容自动置于gh-pages分支. (如有报错, 点进Actions查看原因.)\n在该仓库中: settings-pages-build and deployment选择展示页面由分支gh-pages呈现, 保存.\n待做 新建和推送还是需要手动呢. 再说吧, 以后改改呢.\n试试能不能正确呈现图片\n","date":"2025-10-29T13:17:00+08:00","permalink":"https://zx1360.github.io/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF/","title":"个人博客上线"}]